clear
max_iter = 100;
tolerance = 1e-6;
% Grid size
Nx1 = 30;  % Number of grid points in x1-direction
Nx2 = 30;  % Number of grid points in x2-direction

% Equispaced computational grid
s1 = linspace(0, 1, Nx1); % Computational coordinates in s1
s2 = linspace(0, 1, Nx2); % Computational coordinates in s2
[s1, s2] = meshgrid(s1, s2);

% Initial physical coordinates (equispaced)
x1 = s1;  % Map computational x1-coordinates directly
x2 = s2;  % Map computational x2-coordinates directly

% Plot initial grid
figure; plot(x1, x2, 'k'); hold on; plot(x1', x2', 'k');
title('Initial Equispaced Mesh');
axis equal; hold off

% Define the metric tensor M based on the given equation
[M11, M22] = M(x1, x2);

min_cost = Inf;
% Placeholder for iterative solver
for iter = 1:max_iter
    % Compute coefficients and source terms
    [A1, A2, b1, b2] = AssembleLinearSystem(x1, x2, s1, s2);

    % Solve sparse linear system
    x1_star = A1 \ b1;
    x2_star = A2 \ b2;

    % Update x and y with under-relaxation
    epsilon = 0.001; % Under-relaxation factor
    dx1 = reshape(x1_star, Nx1, Nx2) - x1;
    dx2 = reshape(x2_star, Nx1, Nx2) - x2;

    % Check convergence
    if norm(dx1+dx2, 2) == error
        break
    end
    error = norm(dx1+dx2, 2);
    x1 = x1 + epsilon * dx1;
    x2 = x2 + epsilon * dx2;

    plot(x1, x2, 'k'); hold on; plot(x1', x2', 'k');
    axis equal; hold off;
    pause(0.2);
   
    cost(x1, x2, s1, s2) / (Nx1*Nx2)
end


%%
function [A1, A2, b1, b2] = AssembleLinearSystem(x1, x2, s1, s2)
    [Nx1, Nx2] = size(x1);
    N = Nx1*Nx2;
    sigma1 = 1 / Nx1;
    sigma2 = 1 / Nx2;
    [M11, M22] = M(x1, x2);
    %[dM11dx1, dM22dx2] = DCentral(M11, M22, x1, x2);
    [dM11dx1, dM22dx2] = dMdx(x1, x2);
    [dx1ds1, dx2ds2] = DCentral(x1, x2, s1, s2);
    e = ones(N, 1);

    % x direction: Define the 1D Laplacian operator matrix
    L1D = spdiags([e -2*e e], [-Nx2,0,Nx2], N, N); % 1D Laplacian in x
    A1 = -2*L1D.*M11(:)/sigma1;

    % Modify rows corresponding to boundary points for Dirichlet conditions
    % Find boundary indices
    boundary = [1:Nx1, N-Nx1+1:N]; % Vertical boundary indices
    boundary = unique(boundary);   % Remove duplicates
    % Modify boundary rows
    for idx = boundary
        A1(idx, :) = 0;           % Zero out the row
        A1(idx, idx) = 1;         % Set diagonal entry to 1
    end

    b1 = dM11dx1.*(dx1ds1.^2);
    % Apply x1=0 and x1=1 to the left and right boundary
    b1(:,1) = 0;
    b1(:,end) = 1;
    b1 = b1(:);



    % y direction
    L2D = spdiags([e -2*e e], -1:1, N, N); % 1D Laplacian in y
    A2 = -2*L2D.*M22(:)/sigma2;

    boundary = [1:Nx2:N, Nx1:Nx2:N]; % Horizontal boundary indices
    boundary = unique(boundary);

    % Modify boundary rows
    for idx = boundary
        A2(idx, :) = 0;           % Zero out the row
        A2(idx, idx) = 1;         % Set diagonal entry to 1
    end

    b2 = dM22dx2.*(dx2ds2.^2);
    % Apply x2=0 and x2=1 to the top and bottom boundary
    b2(1,:) = 0;
    b2(end,:) = 1;
    b2 = b2(:);
end

function [M11, M22] = M(x1, x2)
    M11 = 40000 * (1 + 15 * x1).^(-2);
    M22 = 40000 * (1 + 15 * x2).^(-2);
end

function [dM11dx1, dM22dx2] = dMdx(x1, x2)
    dM11dx1 = -1200000 * (1 + 15 * x1).^(-3);
    dM22dx2 = -1200000 * (1 + 15 * x2).^(-3);
end

function L = cost(x1, x2, s1, s2)
    [Nx1, Nx2] = size(x1);
    sigma1 = 1 / Nx1;
    sigma2 = 1 / Nx2;
    [M11, M22] = M(x1, x2);
    [dx1ds1, dx2ds2] = DCentral(x1, x2, s1, s2);
    L1 = sigma1^2 * M11 .* dx1ds1.^2;
    L2 = sigma2^2 * M22 .* dx2ds2.^2;
    L = norm(L1(:)+L2(:), 2);
end

% Current works for dxds and dMdx
function [dx1ds1, dx2ds2] = DCentral(x1, x2, s1, s2)
    dx2ds2 = zeros(size(x2));
    dx2ds2(2:end-1,:) = (x2(3:end,:)-x2(1:end-2,:)) ./ (s2(3:end,:)-s2(1:end-2,:));
    dx2ds2(1,:) = (x2(2,:)-x2(1,:)) ./ (s2(2,:)-s2(1,:));
    dx2ds2(end,:) = (x2(end,:)-x2(end-1,:)) ./ (s2(end,:)-s2(end-1,:));

    dx1ds1 = zeros(size(x1));
    dx1ds1(:,2:end-1) = (x1(:,3:end)-x1(:,1:end-2)) ./ (s1(:,3:end)-s1(:,1:end-2));
    dx1ds1(:,1) = (x1(:,2)-x1(:,1)) ./ (s1(:,2)-s1(:,1));
    dx1ds1(:,end) = (x1(:,end)-x1(:,end-1)) ./ (s1(:,end)-s1(:,end-1));
end


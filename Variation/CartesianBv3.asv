% Second version:  diagonal metric tensor, m11 only depends on x1,
%                  m22 only depends on x2, unit square boundary,
%                  grid points x1 and x2 coordinates are solved in ONE
%                  SYSTEM

clear

addpath('./','./utils')
animation = 1;
pause_time = 0;
make_gif = 1;
gif_name = 'example2.gif';
title_name = 'Cartesian Boundary, Cureved Metric';

max_iter = 300;
tolerance = 1e-6;
epsilon = 0.00002; % Under-relaxation factor

% Grid size
Nx1 = 40;
Nx2 = 40;
N = Nx1*Nx2;

% Equispaced computational coordinates
s1 = linspace(0, 1, Nx1);
s2 = linspace(0, 1, Nx2);
[s1, s2] = meshgrid(s1, s2);

% Initial physical coordinates (equispaced)
x1 = s1;
x2 = s2;

% Plot initial grid
plot(x1, x2, 'k'); hold on; plot(x1', x2', 'k');
title(title_name);
axis equal; hold off
exportgraphics(gcf, gif_name);

[M11, M22] = M(x1, x2);

min_cost = Inf;
for iter = 1:max_iter
    [A, b] = AssembleLinearSystem(x1, x2, s1, s2);
    x_star = A \ b;

    x1_star = x_star(1:N);
    x2_star = x_star(N+1:end);

    dx1 = reshape(x1_star, Nx1, Nx2) - x1;
    dx2 = reshape(x2_star, Nx1, Nx2) - x2;

    % Check convergence
    if Cost(x1, x2, s1, s2, M11, M22) > min_cost
        break
    end

    min_cost = Cost(x1, x2, s1, s2, M11, M22);
    x1 = x1 + epsilon * dx1;
    x2 = x2 + epsilon * dx2;

    plot(x1, x2, 'k'); hold on; plot(x1', x2', 'k');
    title(title_name); xlim([0, 1]); ylim([0,1])
    axis equal; hold off;
    pause(pause_time);
    exportgraphics(gcf, gif_name, Append=true);
end


%%
function [A, b] = AssembleLinearSystem(x1, x2, s1, s2)
    [Nx1, Nx2] = size(x1);
    N = Nx1*Nx2;
    N_all = 2*N;

    sigma1 = 1 / Nx1;
    sigma2 = 1 / Nx2;
    [M11, M22] = M(x1, x2);
    [dM11dx1, dM11dx2, dM22dx1, dM22dx2] = dMdx(x1, x2);
    [dx1ds1, dx2ds2] = DCentral(x1, x2, s1, s2);
    [dx2ds1, dx1ds2] = DCentral(x2, x1, s1, s2);

    % Assemble the stiffness matrix A
    e = ones(N_all, 1);
    L1D = spdiags([e -2*e e], [-Nx2,0,Nx2], N_all, N_all); % 1D Laplacian in s1
    L2D = spdiags([e -2*e e], -1:1, N_all, N_all); % 1D Laplacian in s2
    L = sigma1^2 * L1D + sigma2^2 * L2D;
    Mii = [M11(:); M22(:)];
    A = -2*L.*Mii;

    % For Dirichlet conditions, find boundary indices
    vboundary = [1:Nx1, N-Nx1+1:N]; % Vertical boundary indices
    hboundary = [1:Nx2:N, Nx1:Nx2:N]; % Horizontal boundary indices
    for idx = vboundary
        % For Neumann conditions, set dx2/ds1=0
        sidx = idx+N;
        A(sidx, sidx) = A(sidx, sidx)/2;
        if sidx-Nx2 >= N-Nx2; A(sidx, sidx-Nx2) = 0; end
        if sidx+Nx2 <= N_all; A(sidx, sidx+Nx2) = 0; end
    end
    for idx = hboundary
        % For Neumann conditions, set dx1/ds2=0
        A(idx, idx) = A(idx, idx)/2;
        if idx-1 >= 1; A(idx, idx-1) = 0; end
        if idx+1 <= N; A(idx, idx+1) = 0; end
    end

    for idx = vboundary
        % For Dirichlet conditions
        A(idx, :) = 0;           % Zero out the row
        A(idx, idx) = 1;         % Set diagonal entry to 1
    end

    for idx = hboundary
        % For Dirichlet conditions
        sidx = idx+N;
        A(sidx, :) = 0;
        A(sidx, sidx) = 1;
    end


    % Assemble the vector b
    b1 = dM11dx1.* ((dx1ds1.^2)*sigma1^2 + (dx1ds2.^2)*sigma2^2);
    b1 = b1 + 2*dM11dx2.*(dx2ds1.*dx1ds1*sigma1^2 + dx2ds2.*dx1ds2*sigma2^2);
    b1 = b1 - dM22dx1.*(dx2ds1.^2*sigma1^2 + dx2ds2.^2*sigma2^2);
    % Apply x1=0 and x1=1 to the left and right boundary
    b1(:,1) = 0;
    b1(:,end) = 1;

    b2 = dM22dx2.* ((dx2ds1.^2)*sigma1^2 + (dx2ds2.^2)*sigma2^2);
    b2 = b2 + 2*dM22dx1.*(dx1ds1.*dx2ds1*sigma1^2 + dx1ds2.*dx2ds2*sigma2^2);
    b2 = b2 - dM11dx2.*(dx1ds1.^2*sigma1^2 + dx1ds2.^2*sigma2^2);
    % Apply x2=0 and x2=1 to the top and bottom boundary
    b2(1,:) = 0;
    b2(end,:) = 1;
    b = [b1(:); b2(:)];
end

function [M11, M22] = M(x1, x2)
    M11 = 1000 + 600*sin(2*pi*x1).*sin(2*pi*x2);
    M22 = 1000 - 600*sin(2*pi*x1).*sin(2*pi*x2);
end

function [dM11dx1, dM11dx2, dM22dx1, dM22dx2] = dMdx(x1, x2)
    dM11dx1 = 1200*pi*cos(2*pi*x1).*sin(2*pi*x2);
    dM11dx2 = 1200*pi*sin(2*pi*x1).*cos(2*pi*x2);
    dM22dx1 = -1200*pi*cos(2*pi*x1).*sin(2*pi*x2);
    dM22dx2 = -1200*pi*sin(2*pi*x1).*cos(2*pi*x2);
end

%function L = cost(x1, x2, s1, s2)
%    [Nx1, Nx2] = size(x1);
%    sigma1 = 1 / Nx1;
%    sigma2 = 1 / Nx2;
%    [M11, M22] = M(x1, x2);
%    [dx1ds1, dx2ds2] = DCentral(x1, x2, s1, s2);
%    [dx2ds1, dx1ds2] = DCentral(x2, x1, s1, s2);
%    L1 = sigma1^2 * (M11.*dx1ds1.^2+M22.*dx2ds1.^2);
%    L2 = sigma2^2 * (M22.*dx2ds2.^2+M11.*dx1ds2.^2);
%    L = norm(L1(:)+L2(:), 1) / (Nx1*Nx2);
%end

% Current works for dxds
%function [dx1ds1, dx2ds2] = DCentral(x1, x2, s1, s2)
%    dx2ds2 = zeros(size(x2));
%    dx2ds2(2:end-1,:) = (x2(3:end,:)-x2(1:end-2,:)) ./ (s2(3:end,:)-s2(1:end-2,:));
%    dx2ds2(1,:) = (x2(2,:)-x2(1,:)) ./ (s2(2,:)-s2(1,:));
%    dx2ds2(end,:) = (x2(end,:)-x2(end-1,:)) ./ (s2(end,:)-s2(end-1,:));

%    dx1ds1 = zeros(size(x1));
%    dx1ds1(:,2:end-1) = (x1(:,3:end)-x1(:,1:end-2)) ./ (s1(:,3:end)-s1(:,1:end-2));
%    dx1ds1(:,1) = (x1(:,2)-x1(:,1)) ./ (s1(:,2)-s1(:,1));
%    dx1ds1(:,end) = (x1(:,end)-x1(:,end-1)) ./ (s1(:,end)-s1(:,end-1));
%end

